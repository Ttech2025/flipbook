var textForPages = ["","Clase N° 2 |  Movimientos en 3D                    Temario:                      ●  Implementación de controles de personaje con Input.                    ●  Física en 3D: Rigidbody y Force.                    ●  Raycast:Salto y detección de suelo.                    ●  Conﬁguración de la cámara en juegos 3D: Follow.                     Objetivos de la clase                 Desarrollar controles precisos de personaje en Unity usando el Input.                    ●  Implementar scripts para vincular las entradas del usuario con las acciones del                        personaje.                Aplicar conceptos básicos de física en 3D con Rigidbody y Force.                    ●  Configurar un Rigidbody para que el personaje interactúe de forma realista con el                        entorno.                    ●  Utilizar métodos como AddForce para mover al personaje y realizar acciones como                        saltar.                Integrar Raycast para salto y detección de suelo.                    ●  Implementar un sistema de detección de suelo usando Raycast para evitar saltos en                        el aire.                    ●  Desarrollar scripts que aseguren que el personaje solo pueda saltar cuando está en                        contacto con el suelo.                Configurar una cámara en juegos 3D con un sistema de seguimiento.                    ●  Ajustar la posición y los parámetros de la cámara para optimizar la experiencia del                        jugador.","Input System                   Empezaremos  a  trabajar  utilizando  un  sistema  de  Inputs  distinto  del  que  veníamos                haciendo:                  // Obtener los valores de los ejes horizontales y verticales.                 float horizontalInput = Input.GetAxis(\"Horizontal\"); // Movimiento en el eje X.                 float verticalInput = Input.GetAxis(\"Vertical\");     // Movimiento en el eje Z.                  Input.GetAxis es un método en Unity utilizado para leer la entrada de dispositivos como el                 teclado, el mouse o controladores (gamepads). Devuelve un valor flotante (tipo float) que                representa la intensidad de la entrada en un eje determinado, que puede variar entre -1 y 1.                  Este  método  es  muy  útil  para  manejar  movimiento  o  rotación  en  un  juego,  ya  que                proporciona  un  valor  suave  y continuo, ideal para una experiencia más natural. Los ejes                más  comunes  predefinidos  en  Unity  son  Horizontal  y  Vertical,  que  suelen  estar                 configurados para las teclas de dirección (flechas), las teclas W, A, S, D o los sticks de un                gamepad.                  De  esta  manera  obtendremos  un  resultado  más  fluido  y  versátil  que  el  que  veníamos                haciendo. Un código sencillo de movimiento en 3D se veria asi:                 public float moveSpeed = 5f; // Velocidad de movimiento del jugador.                private Rigidbody rb; // Referencia al Rigidbody.                 void Start(){                 rb = GetComponent<Rigidbody>();  // Obtener la referencia al Rigidbody.                 }                 void FixedUpdate(){                   // Obtener los valores de los ejes horizontales y verticales.                    float horizontalInput = Input.GetAxis(\"Horizontal\"); // Movimiento en el eje X.                  float verticalInput = Input.GetAxis(\"Vertical\");     // Movimiento en el eje Z.                   // Crear un vector de movimiento basado en los valores de los ejes.                   Vector3 movement = new Vector3(horizontalInput, 0, verticalInput);                    movement = movement.normalized;                  // Aplicar movimiento al Rigidbody.                   rb.velocity = new Vector3(movement.x * moveSpeed, rb.velocity.y, movement.z*moveSpeed);                 }","Como verán, no cambia mucho más que la disponibilidad en la que se colocan los datos en                los que sería el “Vector3”. La principal diferencia, como se mencionó en la clase anterior, es                que ahora manejaremos los ejes X,Y,Z. Siendo X,Y para movernos a los alrededores                (horizontal y profundidad) y el eje Y, será para las alturas.                 Es por eso que en este caso dejamos el valor de Y en 0:                 Vector3 movement = new Vector3(horizontalInput, 0, verticalInput);","Salto (Raycast)                   Para seguir interactuando con nuestro nuevo espacio crearemos un salto. Para esto,                deberemos buscar maneras para que reconozca cuando está en el suelo. Como venimos                acostumbrados, hay varias maneras de hacerlo. Por ejemplo, podríamos estar chequeando                la velocidad en Y de nuestro personaje. Si es = a 0 saltaría. Pero en este caso, utilizaremos                el Raycast, una forma sencilla de detección que nos avisará cuando estemos “con los pies                en la tierra”.                 Un Raycast en Unity es una técnica que permite proyectar un rayo invisible desde un punto                en el espacio hacia una dirección y detectar si colisiona con algún objeto dentro de un rango                especificado. Esto es útil para interacciones en el juego, como detección de objetos,                colisiones o validación de posiciones.                 public float jumpForce = 5f; // Fuerza del salto                public float rayLength = 1.1f; // Longitud del Raycast                private Rigidbody rb; // Referencia al Rigidbody del jugador                void Update(){                  // Verificar si el jugador está en el suelo usando un Raycast                  bool isGrounded = Physics.Raycast(transform.position, Vector3.down,                rayLength);                   //Dibujar el rayo en la vista de la escena para depuración                  Debug.DrawRay(transform.position, Vector3.down*rayLength, Color.red);                 //Permitir el salto si el jugador está en el suelo y presiona la barra espaciadora                  if (isGrounded \&\& Input.GetKeyDown(KeyCode.Space)){                     Jump();  }  }                void Jump(){                  // Aplicar fuerza hacia arriba para saltar                      rb.AddForce(0, jumpForce, 0);  }                      Aplicación del Raycast:                   bool isGrounded = Physics.Raycast(transform.position, Vector3.down,                rayLength);                 Este método devuelve un valor booleano (true o false), indicando si el rayo chocó con algo                dentro del rango especificado.                 transform.position:                Representa el punto de origen del rayo. En este caso, el rayo se lanza desde la posición                actual del objeto al que está asociado este script.","Vector3.down:                Es un vector que apunta hacia abajo en el eje Y global. Esto significa que el rayo se                proyecta hacia abajo desde el origen (transform.position), ideal para detectar si hay suelo                debajo del objeto.                 rayLength:                Es un valor flotante (float) que define la distancia máxima que recorrerá el rayo desde su                origen. Si no encuentra un objeto dentro de esta distancia, el método devolverá false.                 bool isGrounded:                Es una variable booleana que almacena el resultado de Physics.Raycast.                     ●  Si el rayo colisiona con algo dentro del rango de rayLength, su valor será true.                    ●  Si no encuentra ningún objeto, será false.                   Si sumamos esta linea de codigo con un condicional sencillo, podemos decirle que solo                salte, “si estoy tocando el piso”:                         if (isGrounded \&\& Input.GetKeyDown(KeyCode.Space)) {                            Jump();                        }                 Con todo lo que armamos, tendremos un codigo de movimiento basico para nuestro primer                juego 3D.                 Recordemos lo que es un RigidBody:                Los Rigidbodies le permite a sus GameObjects actuar bajo el control de la física. El                Rigidbody puede recibir fuerza y torque para hacer que sus objetos se muevan en una                manera realista. Cualquier GameObject debe contener un Rigidbody para ser influenciado                por gravedad, actué debajo fuerzas agregadas vía scripting, o interactuar con otros objetos                a través del motor","Cámara.                   Ahora que nuestro personaje se mueve, nos encontramos con un problema: la cámara.                Hasta ahora posiblemente teníamos una cámara fija para nuestro nivel en 2D. Pero ahora el                mundo será más amplio y con diferentes perspectivas. Es por eso que tendremos que crear                un nuevo sistema.                  Por ahora usaremos un código muy sencillo:                [SerializeField] private Transform character;                     [SerializeField] private float ejeX = 0f;                    [SerializeField] private float ejeY = 0f;                     [SerializeField] private float ejeZ = 0f;                     void Update() {                     transform.position = character.position + new Vector3(ejeX, ejeY, ejeZ);                         transform.LookAt(character);                }                  Con esto lo único que haremos es setear algunas variables desde el inspector hasta que                quede una visión que nos guste.                 transform.position = character.position + new Vector3(ejeX, ejeY, ejeZ);                 Nuestro  código  irá  igualando  su  posición  a  la  del  personaje  mientras  suma  los  valores                 seteados. Esto hará una suerte de “seguimiento” del objeto siempre desde el punto de vista                buscado.                 Por último colocaremos  transform.LookAt(character); para estar observando constantemente                 al player.","Un nuevo giro en el pedido.                    Mientras  trabajamos  en  el  prototipo,  recibimos  un  mensaje  urgente  del  cliente:  están                evaluando  la  competencia  y  han  notado  que  otros  desarrolladores están implementando                 mecánicas más avanzadas. Nos piden incorporar dos nuevas habilidades que hagan que                el personaje destaque:                      1.  Doble Salto: Los/as jugadores/as podrán realizar un segundo salto mientras están                        en el aire, permitiendo alcanzar nuevas alturas y zonas inaccesibles.                     2.  Dash: Un movimiento rápido y dinámico que permitirá esquivar obstáculos o                        alcanzar áreas con precisión.                  El  cliente  cree  que  estas  habilidades  agregarán  profundidad  y  dinamismo  al  prototipo,                mostrando el potencial del proyecto. Sin embargo, también menciona que la implementación                 debe sentirse fluida y natural, sin romper la inmersión.                  El reto adicional.                El  tiempo  sigue  siendo  limitado.  Debemos  integrar  estas  mecánicas  utilizando  las                herramientas  que  ya  conocemos  y  asegurarnos  de  que  encajen  a  la  perfección  con  el                sistema de física y controles existentes.                  Manos a la obra.                 Primero,  terminemos  el  movimiento  base  del  personaje.  Luego,  exploraremos  cómo                incorporar  el  doble  salto  y  el  dash  sin  comprometer  la  jugabilidad.  ¡Demostremos  que                 nuestro equipo está a la altura del desafío!","Mecánica: Double Jump                   Empecemos a construir nuestras mecánicas. Crearemos un doble salto o “Double Jump”.                 Para esto tendremos que modificar nuestro código de salto, haciendo que                  void Update(){                 if (saltosRestantes <= 0){                   // Verificar si el jugador está en el suelo usando un Raycast                 isGrounded = Physics.Raycast(transform.position, Vector3.down, rayLength);                  if (isGrounded){                    saltosRestantes = 2;                            }  }                    // Permitir el salto si el jugador está en el suelo y presiona la barra espaciadora y tiene saltos                restantes                   if (isGrounded \&\& Input.GetKeyDown(KeyCode.Space) \&\& saltosRestantes > 0){                    saltosRestantes--;                    Jump();                        }  }                  void Jump(){                   // Aplicar fuerza hacia arriba para saltar                    rb.velocity = new Vector3(rb.velocity.x, 0 , rb.velocity.z);                    rb.AddForce(0, jumpForce, 0);                    }                   Explicación del código:                  1) Verificación de si el jugador está en el suelo                    if (saltosRestantes <= 0)                {                    // Verificar si el jugador está en el suelo usando un Raycast                    isGrounded = Physics.Raycast(transform.position, Vector3.down, rayLength);                    if (isGrounded)                    {                        saltosRestantes = 2;                    }                }","●  saltosRestantes:                           ○  Controla cuántos saltos adicionales puede realizar el jugador.                           ○  Se reinicia a 2 cuando el jugador vuelve al suelo.                    ●  Raycast (Physics.Raycast):                           ○  Lanza un rayo invisible desde la posición del jugador (transform.position)                               hacia abajo (Vector3.down) con una longitud (rayLength) para detectar si está                               tocando el suelo.                           ○  Si el rayo detecta el suelo (isGrounded es true), el contador de saltos                               (saltosRestantes) se reinicia a 2.                 Esto asegura que los saltos solo se recargan cuando el jugador está en contacto con el                suelo.                 2) Salto del jugador:                 if (isGrounded \&\& Input.GetKeyDown(KeyCode.Space) \&\& saltosRestantes > 0){                      saltosRestantes--;                     Jump();                  }                  Condiciones para saltar:                     ●  El jugador debe estar en el suelo (isGrounded).                    ●  La tecla de salto (Space) debe ser presionada.                    ●  Debe tener al menos un salto disponible (saltosRestantes > 0).                  Reducción de saltos restantes:                     ●  Cada vez que salta, saltosRestantes se reduce en 1. Esto permite un máximo de dos                        saltos consecutivos.                 Llamada al método Jump:                      ●  Ejecuta la lógica del salto para aplicar una fuerza hacia arriba.                  3) Lógica del salto                 void Jump()                {                    // Aplicar fuerza hacia arriba para saltar                    rb.velocity = new Vector3(rb.velocity.x, 0, rb.velocity.z);                     rb.AddForce(0, jumpForce, 0);                }","rb.velocity:                     ●  Restablece la velocidad vertical (y) a 0 para evitar acumulaciones de fuerzas de                        salto si el jugador salta rápidamente varias veces seguidas. Las velocidades en los                        ejes x y z se mantienen iguales para no alterar el movimiento horizontal.                 rb.AddForce:                      ●  Aplica una fuerza hacia arriba (y) usando la magnitud definida en jumpForce. Esto                        hace que el jugador salte.","Mecánica: Dash                   Para terminar crearemos un “Dash” sencillo para agregarle más habilidades a nuestro                personaje.                Esto lo haremos creando una suerte de teletransporte o “Teleport” corto, siendo un método                muy común que se acompaña con alguna animación o estela de particular para disimular.                  Código:                        private Vector3 previousPosition; // Almacena la posición del objeto en el frame anterior                        public Vector3 currentDirection; // Dirección actual del movimiento                        void Start()  {                            // Inicializar la posición previa con la posición inicial del objeto                            previousPosition = transform.position;                         }                         void Update()  {                            CalculateDirection();                            Teleport();                        }                        void Teleport() {                          if (Input.GetKeyDown(KeyCode.E))  {                                Debug.Log(\"Dash\");                                transform.position += currentDirection * 5;                                Debug.Log(currentDirection);                                }                        }                 void CalculateDirection()  {                        // Calcular la dirección del movimiento                       Vector3 movement = transform.position - previousPosition;                         // Normalizar la dirección para obtener un vector unitario                        movement = new Vector3(movement.x, 0, movement.z);                        if (movement != Vector3.zero)   {                            currentDirection = movement.normalized;                        }                            // Actualizar la posición previa                            previousPosition = transform.position;                        }","Explicación del código                 Este código implementa un sistema que calcula la dirección de movimiento de un objeto en                Unity y permite al jugador realizar un teletransporte instantáneo (dash) en esa dirección al                presionar la tecla E. A continuación, explicamos en detalle cada parte del código.                     Componentes:                            ○  previousPosition: Almacena la posición del objeto en el frame anterior. Es                                usada para calcular la dirección del movimiento.                           ○  currentDirection: Representa la dirección normalizada del movimiento del                               objeto. Es el vector unitario que indica hacia dónde se mueve el objeto.                    Inicialización (Start)                         void Start()                 {                     previousPosition = transform.position;                }                   Al  iniciar  el  juego,  se  guarda  la  posición  inicial  del  objeto  en  previousPosition  para                 compararla en cada frame.                   Cálculo de Dirección (CalculateDirection)                 void CalculateDirection(){                     Vector3 movement = transform.position - previousPosition;                     movement = new Vector3(movement.x, 0, movement.z);                     if (movement != Vector3.zero)  {                         currentDirection = movement.normalized;                    }                     previousPosition = transform.position;}","Cálculo de Movimiento:                     ●  La dirección del movimiento se calcula como la diferencia entre la posición actual                        (transform.position) y la posición anterior (previousPosition).                      ●  La componente vertical (y) del movimiento se ignora, ya que solo se calculan                        movimientos en el plano horizontal (x y z).                 Normalización:                     ●  Si el objeto se mueve (movement != Vector3.zero), el vector de movimiento se                         normaliza. Esto asegura que currentDirection sea un vector unitario (magnitud de 1),                        que representa únicamente la dirección.                 Actualización de previousPosition:                     ●  Se guarda la posición actual como la nueva posición previa para usarla en el                         siguiente frame.                 Teletransporte (Teleport)                 void Teleport(){                     if (Input.GetKeyDown(KeyCode.E)){                         Debug.Log(\"Dash\");                         transform.position += currentDirection * 5;                         Debug.Log(currentDirection); }}                 Activación del Teletransporte:                     ●  Si el jugador presiona la tecla E, se activa el teletransporte.                 Cálculo de la Nueva Posición:                     ●  El objeto se mueve en la dirección almacenada en currentDirection multiplicada por                         una distancia fija de 5 unidades.                 Depuración:                     ●  Usa Debug.Log para imprimir un mensaje en la consola y verificar la dirección en la                        que se realiza el teletransporte.                 De  esta  forma,  terminaremos  con  un  personaje  con  un  sistema de movimiento bastante                 completo.","Situación inicial en TechLab.                                                            ¡Bienvenido  de  nuevo  al  equipo  de  TalentoLab!                                                         Tras el primer día de introducción, ya se tiene listo                                                         un  pedido  urgente  de  un  cliente.  Se  trata  de  un                                                         prototipo que servirá para demostrar la jugabilidad                                                         de un personaje en un entorno 3D.                                                          El cliente, un inversionista exigente pero visionario,                quiere asegurarse de que la base de control del personaje sea perfecta antes de aprobar el                presupuesto para el resto del desarrollo. Por eso, debemos crear un personaje que pueda                moverse  con  fluidez,  saltar  y  detectar  el  suelo  con  precisión.  Además,  este  personaje                deberá  ser  compatible  con  un  sistema  de  cámara dinámico que permita a los jugadores                seguirlo mientras exploran el entorno 3D.                 ¿Qué necesitamos lograr?                      1.  Implementar controles para que el personaje pueda moverse en el mundo 3D. El                        cliente ha pedido que utilicemos el Input System más moderno para garantizar la                        mejor experiencia.                    2.  Simular movimiento realista mediante las leyes de la física, integrando componentes                        como el Rigidbody y aplicando fuerzas.                    3.  Diseñar un sistema de detección con Raycast para que el personaje pueda saltar                        únicamente cuando esté en el suelo.                    4.  Configurar una cámara que siga al personaje, asegurando que la perspectiva sea                        cómoda y funcional para el jugador.","Ejercicios prácticos:                                    ¡Es  tu  momento  para  brillar! Uno de nuestros desarrolladores, Giuseppe,                                desea  que  lo  asistas  con  un  demo.  Si  logramos  impresionar  con  esto,                                podríamos  desbloquear  más  recursos  para el proyecto Nexus. Pero tené                                cuidado,  porque  cualquier  detalle  fuera  de  lugar  podría  costarnos  su                                confianza.                  Comencemos por darle vida a nuestro personaje en el mundo 3D. ¡Adelante!                 Requerimientos:                     1.  Implementar en tu personaje las mecánicas vistas en clase (Dash y Double Jump).                     2.  Pensar, buscar y agregar 1 mecánica más a elección. Posibles ejemplos:                            a.  Invocación de objetos como plataformas temporales, disparos, entre otros.                            b.  Agacharse (bajando la Y del objeto al mantener apretado un botón).                            c.  Sprint                      Materiales y recursos adicionales.                  Input.GetAxis                https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Input.GetAxis.html                 RigidBody:                https://docs.unity3d.com/ScriptReference/Rigidbody.html                 AddForce:                https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Rigidbody.AddForce.html                 Raycast:                https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Physics.Raycast.html","Preguntas para reflexionar.                      ●  ¿Qué otras aplicaciones puede tener el Raycast?                    ●  ¿Qué mecánicas podríamos crear que se basen en juegos de plataforma?                    ●  ¿Qué importancia tienen las mecánicas en el juego y su historia?                    Próximos pasos.                  En la siguiente clase profundizaremos en las plataformas para nuestro juego. Creamos                diferentes tipos de ellas para poder mezclar y colocar en el proyecto según nos sea                conveniente.",""];